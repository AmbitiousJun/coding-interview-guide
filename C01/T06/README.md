# 用栈来求解汉诺塔问题

## 描述

汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有 N 层的时候，打印最优移动过程和最优移动总步数。

## 总结

### 解法1: 递归

递归终止条件：只剩下一层塔需要移动的情况下

- 需要从左右两侧移动到中间或者从中间移动到左右两侧时, 消耗 1 步可完成
- 需要从左移动到右或者从右移动到左时, 消耗 2 步可完成

需要移动多层塔的情况下

- 需要从左右两侧移动到中间或者从中间移动到左右两侧时, 分为 3 个大步骤
   - 将前 n-1 层先移动到除了 from 和 to 的另外一边, 消耗若干步 **（递归）**
   - 将最后一层从 from 移动到 to, 消耗 1 步
   - 将前 n-1 层从另外一边移动到 to, 消耗若干步 **（递归）**
- 需要从左移动到右或者从右移动到左时, 分为 5 个大步骤
   - 将前 n-1 层从 from 移动到 to, 消耗若干步 **（递归）**
   - 将最后一层从 from 移动到 mid, 消耗 1 步
   - 将前 n-1 层从 to 移动到 from, 消耗若干步 **（递归）**
   - 将最后一层从 mid 移动到 to, 消耗 1 步
   - 将前 n-1 层从 from 移动到 to, 消耗若干步 **（递归）**

### 解法2：使用栈模拟

核心思路:

游戏规则限制为, 不管怎样每一步都需要经过 “中间塔”, 这就使得在进行每一步的决策时, 总共有 4 种移动情况:

1. 左 -> 中
2. 中 -> 左
3. 中 -> 右
4. 右 -> 中

两个约束条件:

1. 每一步移动时, 必须遵循 “小压大”, 也就是说, 每个栈中的元素, 必须保持从底到顶降序排列
2. 遵循相邻不可逆原则, 比如上一步走了 `左 -> 中`, 当前步就不能走 `中 -> 左`, 因为没有意义, 最终的步数也不是最少步数

编程技巧:

1. 利用枚举常量和指针变量, 实现传参的形式实时记录上一步的移动记录
2. 提前往每个栈中压入一个绝对大的值, 这样可以省去在后续代码中不必要的判空操作