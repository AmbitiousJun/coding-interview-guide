# 单调栈结构

## 描述

① 给定一个不含有重复值的数组 `arr`，找到每一个 `i` 位置左边和右边离 `i` 位置最近且值比 `arr[i]` 小的位置，返回所有位置相应的信息。

② 进阶问题：给定一个**可能含有重复值**的数组 `arr`，找到每一个 `i` 位置左边和右边离 `i` 位置最近且值比 `arr[i]` 小的位置，返回所有位置相应的信息。

要求时间复杂度都达到 `O(n)`

## 举例

`arr = {3, 4, 1, 5, 6, 2, 7}`

返回如下二维数组作为结果：

```go
{
  {-1,  2},
  { 0,  2},
  {-1, -1},
  { 2,  5},
  { 3,  5},
  { 2, -1},
  { 5, -1}
}
```

## 总结

**对于原问题**：

最简单的解法是在遍历数组 `arr` 的时候，分别往左和往右寻找到对于当前元素符合题意的两个答案，这种方法的时间复杂度是 `O(n²)`，效率比较低下。

更优的解法是使用单调栈结构，可以在 `O(n)` 的时间复杂度下解决当前问题

> 单调栈的含义：在压栈的时候时刻保持着“小压大”或者“大压小”的原则，使得栈中的元素是有序排列的状态

具体的，在遍历到每个元素 `i` 时，在准备压栈前需要循环进行判断：

1. `栈空或者 arr[i] > 栈顶元素`：符合单调栈含义，直接将 `i` 压入栈中
2. `arr[i] < 栈顶元素`：弹出栈顶元素 `x`，此时 `i` 即为 `x` 在 `res[x]` 中的右值，而此时的栈顶元素为 `x` 在 `res[x]` 中的左值（栈空的话就是 -1）

`arr` 遍历完成之后，栈中剩下的元素，都是在数组 `arr` 中找不到右值 `right` 使得 `res[right] < res[x]`，即 `res[x]` 的右值都为 -1，此时只需要循环依次弹出栈顶元素，左值的判断方法依旧是根据新栈顶元素来判断，栈空就为 -1。

**对于进阶问题**：

因为数组 `arr` 中可能存在重复的元素，所以在使用单调栈结构时，栈中的元素不再是 `int` 而是 `list`，把所有的重复元素聚在一起看成一个整体。在判断左值时，如果 `list` 中有多个元素，以 `list` 最右侧的值为结果。
